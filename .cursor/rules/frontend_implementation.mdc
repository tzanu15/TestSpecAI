---
description: Frontend Implementation Guidelines for TestSpecAI
globs: frontend/**/*
alwaysApply: true
---

# Frontend Implementation Guidelines

## **React Application Structure**

### **✅ Main Application Setup**
```typescript
// frontend/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { ConfigProvider } from 'antd'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import App from './App'
import './styles/globals.css'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
})

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <ConfigProvider
        theme={{
          token: {
            colorPrimary: '#1890ff',
            borderRadius: 6,
          },
        }}
      >
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </ConfigProvider>
    </QueryClientProvider>
  </React.StrictMode>,
)
```

### **✅ App Component Structure**
```typescript
// frontend/src/App.tsx
import { Routes, Route } from 'react-router-dom'
import { Layout } from './components/common/Layout'
import { RequirementsPage } from './pages/RequirementsPage'
import { TestSpecsPage } from './pages/TestSpecsPage'
import { ParametersPage } from './pages/ParametersPage'
import { CommandsPage } from './pages/CommandsPage'
import { DashboardPage } from './pages/DashboardPage'

function App() {
  return (
    <Layout>
      <Routes>
        <Route path="/" element={<DashboardPage />} />
        <Route path="/requirements" element={<RequirementsPage />} />
        <Route path="/test-specs" element={<TestSpecsPage />} />
        <Route path="/parameters" element={<ParametersPage />} />
        <Route path="/commands" element={<CommandsPage />} />
      </Routes>
    </Layout>
  )
}

export default App
```

## **TypeScript Types (CRITICAL RULES)**

### **✅ Base Types**
```typescript
// frontend/src/types/api.ts
export interface BaseEntity {
  id: string
  created_at: string
  updated_at: string
  created_by: string
  is_active: boolean
}

export interface PaginatedResponse<T> {
  items: T[]
  total: number
  page: number
  per_page: number
  total_pages: number
}

export interface ApiError {
  detail: string
  type: string
}

export interface LoadingState {
  isLoading: boolean
  error: string | null
}
```

### **✅ Entity Types**
```typescript
// frontend/src/types/requirements.ts
import { BaseEntity } from './api'

export interface Requirement extends BaseEntity {
  title: string
  description: string
  category_id: string
  source: string
  metadata: Record<string, any>
}

export interface RequirementCategory extends BaseEntity {
  name: string
  description: string
}

export interface RequirementCreate {
  title: string
  description: string
  category_id: string
  source?: string
  metadata?: Record<string, any>
}

export interface RequirementUpdate {
  title?: string
  description?: string
  category_id?: string
  metadata?: Record<string, any>
}
```

### **✅ Test Specification Types**
```typescript
// frontend/src/types/testSpecs.ts
import { BaseEntity } from './api'

export interface TestStep {
  id: string
  test_specification_id: string
  action: GenericCommandReference
  expected_result: GenericCommandReference
  description?: string
  sequence_number: number
}

export interface TestSpecification extends BaseEntity {
  name: string
  description: string
  requirement_ids: string[]
  precondition: string
  test_steps: TestStep[]
  postcondition: string
  test_data_description: Record<string, any>
  functional_area: 'UDS' | 'Communication' | 'ErrorHandler' | 'CyberSecurity'
}

export interface GenericCommandReference {
  command_id: string
  command_template: string
  populated_parameters: Record<string, string>
}
```

## **Zustand State Management (CRITICAL RULES)**

### **✅ Store Base Pattern**
```typescript
// frontend/src/stores/baseStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

export interface BaseStoreState<T> {
  items: T[]
  loading: boolean
  error: string | null
  selectedItem: T | null
}

export interface BaseStoreActions<T> {
  setItems: (items: T[]) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  setSelectedItem: (item: T | null) => void
  addItem: (item: T) => void
  updateItem: (id: string, updates: Partial<T>) => void
  removeItem: (id: string) => void
  reset: () => void
}

export function createBaseStore<T extends { id: string }>(
  name: string,
  initialState: BaseStoreState<T>
) {
  return create<BaseStoreState<T> & BaseStoreActions<T>>()(
    devtools(
      (set, get) => ({
        ...initialState,
        
        setItems: (items) => set({ items }),
        setLoading: (loading) => set({ loading }),
        setError: (error) => set({ error }),
        setSelectedItem: (selectedItem) => set({ selectedItem }),
        
        addItem: (item) => set((state) => ({ 
          items: [...state.items, item] 
        })),
        
        updateItem: (id, updates) => set((state) => ({
          items: state.items.map(item => 
            item.id === id ? { ...item, ...updates } : item
          )
        })),
        
        removeItem: (id) => set((state) => ({
          items: state.items.filter(item => item.id !== id)
        })),
        
        reset: () => set(initialState),
      }),
      { name }
    )
  )
}
```

### **✅ Entity-Specific Stores**
```typescript
// frontend/src/stores/requirementsStore.ts
import { createBaseStore } from './baseStore'
import { Requirement } from '../types/requirements'

interface RequirementsState {
  categories: RequirementCategory[]
  filters: {
    category_id?: string
    search?: string
  }
}

interface RequirementsActions {
  setCategories: (categories: RequirementCategory[]) => void
  setFilters: (filters: Partial<RequirementsState['filters']>) => void
  clearFilters: () => void
}

const initialState = {
  items: [] as Requirement[],
  loading: false,
  error: null,
  selectedItem: null,
  categories: [] as RequirementCategory[],
  filters: {} as RequirementsState['filters'],
}

export const useRequirementsStore = create<
  RequirementsState & RequirementsActions
>()(
  devtools(
    (set, get) => ({
      ...initialState,
      
      setCategories: (categories) => set({ categories }),
      setFilters: (filters) => set((state) => ({
        filters: { ...state.filters, ...filters }
      })),
      clearFilters: () => set({ filters: {} }),
      
      // Inherit base actions
      ...createBaseStore('requirements', initialState),
    }),
    { name: 'requirements-store' }
  )
)
```

## **API Services (CRITICAL RULES)**

### **✅ Base API Service**
```typescript
// frontend/src/services/api.ts
import axios, { AxiosInstance, AxiosResponse } from 'axios'
import { ApiError } from '../types/api'

class ApiService {
  private client: AxiosInstance

  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    })

    this.setupInterceptors()
  }

  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        // Add auth token if available
        const token = localStorage.getItem('auth_token')
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => response,
      (error) => {
        const apiError: ApiError = {
          detail: error.response?.data?.detail || 'An error occurred',
          type: error.response?.data?.type || 'UnknownError'
        }
        return Promise.reject(apiError)
      }
    )
  }

  async get<T>(url: string, params?: any): Promise<T> {
    const response = await this.client.get<T>(url, { params })
    return response.data
  }

  async post<T>(url: string, data?: any): Promise<T> {
    const response = await this.client.post<T>(url, data)
    return response.data
  }

  async put<T>(url: string, data?: any): Promise<T> {
    const response = await this.client.put<T>(url, data)
    return response.data
  }

  async delete<T>(url: string): Promise<T> {
    const response = await this.client.delete<T>(url)
    return response.data
  }
}

export const apiService = new ApiService()
```

### **✅ Entity-Specific Services**
```typescript
// frontend/src/services/requirements.ts
import { apiService } from './api'
import { 
  Requirement, 
  RequirementCategory, 
  RequirementCreate, 
  RequirementUpdate 
} from '../types/requirements'
import { PaginatedResponse } from '../types/api'

export class RequirementsService {
  async getRequirements(params?: {
    skip?: number
    limit?: number
    category_id?: string
    search?: string
  }): Promise<Requirement[]> {
    return apiService.get<Requirement[]>('/requirements', params)
  }

  async getRequirement(id: string): Promise<Requirement> {
    return apiService.get<Requirement>(`/requirements/${id}`)
  }

  async createRequirement(data: RequirementCreate): Promise<Requirement> {
    return apiService.post<Requirement>('/requirements', data)
  }

  async updateRequirement(id: string, data: RequirementUpdate): Promise<Requirement> {
    return apiService.put<Requirement>(`/requirements/${id}`, data)
  }

  async deleteRequirement(id: string): Promise<void> {
    return apiService.delete<void>(`/requirements/${id}`)
  }

  async getCategories(): Promise<RequirementCategory[]> {
    return apiService.get<RequirementCategory[]>('/requirements/categories')
  }
}

export const requirementsService = new RequirementsService()
```

## **Custom React Hooks (CRITICAL RULES)**

### **✅ Data Fetching Hooks**
```typescript
// frontend/src/hooks/useRequirements.ts
import { useState, useEffect } from 'react'
import { useRequirementsStore } from '../stores/requirementsStore'
import { requirementsService } from '../services/requirements'
import { Requirement, RequirementCreate, RequirementUpdate } from '../types/requirements'

export const useRequirements = () => {
  const store = useRequirementsStore()
  const [isInitialized, setIsInitialized] = useState(false)

  // Load requirements on mount
  useEffect(() => {
    if (!isInitialized) {
      loadRequirements()
      loadCategories()
      setIsInitialized(true)
    }
  }, [isInitialized])

  const loadRequirements = async () => {
    try {
      store.setLoading(true)
      store.setError(null)
      const requirements = await requirementsService.getRequirements(store.filters)
      store.setItems(requirements)
    } catch (error) {
      store.setError(error instanceof Error ? error.message : 'Failed to load requirements')
    } finally {
      store.setLoading(false)
    }
  }

  const createRequirement = async (data: RequirementCreate) => {
    try {
      store.setLoading(true)
      const newRequirement = await requirementsService.createRequirement(data)
      store.addItem(newRequirement)
      return newRequirement
    } catch (error) {
      store.setError(error instanceof Error ? error.message : 'Failed to create requirement')
      throw error
    } finally {
      store.setLoading(false)
    }
  }

  const updateRequirement = async (id: string, data: RequirementUpdate) => {
    try {
      store.setLoading(true)
      const updatedRequirement = await requirementsService.updateRequirement(id, data)
      store.updateItem(id, updatedRequirement)
      return updatedRequirement
    } catch (error) {
      store.setError(error instanceof Error ? error.message : 'Failed to update requirement')
      throw error
    } finally {
      store.setLoading(false)
    }
  }

  const deleteRequirement = async (id: string) => {
    try {
      store.setLoading(true)
      await requirementsService.deleteRequirement(id)
      store.removeItem(id)
    } catch (error) {
      store.setError(error instanceof Error ? error.message : 'Failed to delete requirement')
      throw error
    } finally {
      store.setLoading(false)
    }
  }

  const loadCategories = async () => {
    try {
      const categories = await requirementsService.getCategories()
      store.setCategories(categories)
    } catch (error) {
      console.error('Failed to load categories:', error)
    }
  }

  return {
    // State
    requirements: store.items,
    categories: store.categories,
    loading: store.loading,
    error: store.error,
    selectedRequirement: store.selectedItem,
    filters: store.filters,
    
    // Actions
    loadRequirements,
    createRequirement,
    updateRequirement,
    deleteRequirement,
    setSelectedRequirement: store.setSelectedItem,
    setFilters: store.setFilters,
    clearFilters: store.clearFilters,
  }
}
```

### **✅ Form Handling Hooks**
```typescript
// frontend/src/hooks/useForm.ts
import { useState, useCallback } from 'react'
import { z } from 'zod'

export const useForm = <T extends Record<string, any>>(
  initialValues: T,
  validationSchema?: z.ZodSchema<T>
) => {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({})
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({})

  const setValue = useCallback((field: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [field]: value }))
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }))
    }
  }, [errors])

  const setFieldTouched = useCallback((field: keyof T) => {
    setTouched(prev => ({ ...prev, [field]: true }))
  }, [])

  const validate = useCallback(() => {
    if (!validationSchema) return true

    try {
      validationSchema.parse(values)
      setErrors({})
      return true
    } catch (error) {
      if (error instanceof z.ZodError) {
        const newErrors: Partial<Record<keyof T, string>> = {}
        error.errors.forEach((err) => {
          if (err.path[0]) {
            newErrors[err.path[0] as keyof T] = err.message
          }
        })
        setErrors(newErrors)
      }
      return false
    }
  }, [values, validationSchema])

  const reset = useCallback(() => {
    setValues(initialValues)
    setErrors({})
    setTouched({})
  }, [initialValues])

  return {
    values,
    errors,
    touched,
    setValue,
    setFieldTouched,
    validate,
    reset,
    isValid: Object.keys(errors).length === 0,
  }
}
```

## **Component Patterns (CRITICAL RULES)**

### **✅ Page Component Pattern**
```typescript
// frontend/src/pages/RequirementsPage.tsx
import React, { useEffect } from 'react'
import { Card, Button, Space, Typography } from 'antd'
import { PlusOutlined } from '@ant-design/icons'
import { RequirementsList } from '../components/requirements/RequirementsList'
import { RequirementForm } from '../components/requirements/RequirementForm'
import { useRequirements } from '../hooks/useRequirements'

const { Title } = Typography

export const RequirementsPage: React.FC = () => {
  const {
    requirements,
    loading,
    error,
    loadRequirements,
    createRequirement,
    updateRequirement,
    deleteRequirement,
  } = useRequirements()

  useEffect(() => {
    loadRequirements()
  }, [loadRequirements])

  const handleCreate = async (data: any) => {
    try {
      await createRequirement(data)
      // Show success message
    } catch (error) {
      // Error is handled in the hook
    }
  }

  if (error) {
    return (
      <Card>
        <Typography.Text type="danger">{error}</Typography.Text>
      </Card>
    )
  }

  return (
    <div>
      <div style={{ marginBottom: 24 }}>
        <Title level={2}>Requirements Management</Title>
        <Space>
          <Button type="primary" icon={<PlusOutlined />}>
            Add Requirement
          </Button>
        </Space>
      </div>

      <RequirementsList
        requirements={requirements}
        loading={loading}
        onEdit={updateRequirement}
        onDelete={deleteRequirement}
      />
    </div>
  )
}
```

### **✅ List Component Pattern**
```typescript
// frontend/src/components/requirements/RequirementsList.tsx
import React from 'react'
import { Table, Button, Space, Tag, Popconfirm } from 'antd'
import { EditOutlined, DeleteOutlined } from '@ant-design/icons'
import { Requirement } from '../../types/requirements'

interface RequirementsListProps {
  requirements: Requirement[]
  loading: boolean
  onEdit: (id: string, data: any) => Promise<void>
  onDelete: (id: string) => Promise<void>
}

export const RequirementsList: React.FC<RequirementsListProps> = ({
  requirements,
  loading,
  onEdit,
  onDelete,
}) => {
  const columns = [
    {
      title: 'Title',
      dataIndex: 'title',
      key: 'title',
      sorter: (a: Requirement, b: Requirement) => a.title.localeCompare(b.title),
    },
    {
      title: 'Description',
      dataIndex: 'description',
      key: 'description',
      ellipsis: true,
    },
    {
      title: 'Category',
      dataIndex: 'category_id',
      key: 'category_id',
      render: (categoryId: string) => (
        <Tag color="blue">{categoryId}</Tag>
      ),
    },
    {
      title: 'Source',
      dataIndex: 'source',
      key: 'source',
      render: (source: string) => (
        <Tag color={source === 'manual' ? 'green' : 'orange'}>
          {source}
        </Tag>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_: any, record: Requirement) => (
        <Space>
          <Button
            type="link"
            icon={<EditOutlined />}
            onClick={() => onEdit(record.id, record)}
          >
            Edit
          </Button>
          <Popconfirm
            title="Are you sure you want to delete this requirement?"
            onConfirm={() => onDelete(record.id)}
            okText="Yes"
            cancelText="No"
          >
            <Button
              type="link"
              danger
              icon={<DeleteOutlined />}
            >
              Delete
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ]

  return (
    <Table
      columns={columns}
      dataSource={requirements}
      loading={loading}
      rowKey="id"
      pagination={{
        pageSize: 10,
        showSizeChanger: true,
        showQuickJumper: true,
        showTotal: (total, range) =>
          `${range[0]}-${range[1]} of ${total} items`,
      }}
    />
  )
}
```

## **Styling Guidelines (CRITICAL RULES)**

### **✅ Ant Design Theme Configuration**
```typescript
// frontend/src/styles/theme.ts
export const theme = {
  token: {
    colorPrimary: '#1890ff',
    colorSuccess: '#52c41a',
    colorWarning: '#faad14',
    colorError: '#ff4d4f',
    colorInfo: '#1890ff',
    borderRadius: 6,
    wireframe: false,
  },
  components: {
    Layout: {
      headerBg: '#001529',
      siderBg: '#001529',
    },
    Menu: {
      darkItemBg: '#001529',
      darkSubMenuItemBg: '#000c17',
    },
    Table: {
      headerBg: '#fafafa',
    },
  },
}
```

### **✅ Global Styles**
```css
/* frontend/src/styles/globals.css */
@import '~antd/dist/reset.css';

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.ant-layout {
  min-height: 100vh;
}

.ant-layout-content {
  padding: 24px;
  background: #f0f2f5;
}

.page-header {
  margin-bottom: 24px;
}

.page-header h1 {
  margin: 0;
  color: #262626;
}

.page-header .ant-btn {
  margin-left: 16px;
}

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
}

.error-container {
  text-align: center;
  padding: 24px;
}

.error-container .ant-result {
  padding: 0;
}
```

## **Testing Requirements (MANDATORY)**

### **✅ Component Testing**
```typescript
// frontend/src/components/__tests__/RequirementsList.test.tsx
import React from 'react'
import { render, screen, fireEvent } from '@testing-library/react'
import { RequirementsList } from '../requirements/RequirementsList'
import { Requirement } from '../../types/requirements'

const mockRequirements: Requirement[] = [
  {
    id: '1',
    title: 'Test Requirement',
    description: 'Test Description',
    category_id: 'test-category',
    source: 'manual',
    metadata: {},
    created_at: '2023-01-01T00:00:00Z',
    updated_at: '2023-01-01T00:00:00Z',
    created_by: 'test-user',
    is_active: true,
  },
]

const mockProps = {
  requirements: mockRequirements,
  loading: false,
  onEdit: jest.fn(),
  onDelete: jest.fn(),
}

describe('RequirementsList', () => {
  it('renders requirements list', () => {
    render(<RequirementsList {...mockProps} />)
    expect(screen.getByText('Test Requirement')).toBeInTheDocument()
  })

  it('calls onEdit when edit button is clicked', () => {
    render(<RequirementsList {...mockProps} />)
    fireEvent.click(screen.getByText('Edit'))
    expect(mockProps.onEdit).toHaveBeenCalledWith('1', mockRequirements[0])
  })
})
```

## **Implementation Checklist**

### **Before Starting Any Frontend Task:**
- [ ] **Check component structure** follows patterns
- [ ] **Verify TypeScript types** are properly defined
- [ ] **Ensure Zustand stores** follow base pattern
- [ ] **Implement proper error handling**
- [ ] **Add loading states**
- [ ] **Write tests** for components
- [ ] **Follow Ant Design** component usage

### **Code Quality Checks:**
- [ ] **No any types** (use proper TypeScript)
- [ ] **Proper error boundaries**
- [ ] **Responsive design** implemented
- [ ] **Accessibility** considerations
- [ ] **Performance optimization**
- [ ] **Proper state management**
- [ ] **Clean component structure**

---

**Remember**: Frontend implementation must be user-friendly, performant, and follow React best practices. Always test thoroughly before marking tasks complete.